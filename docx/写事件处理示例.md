# 写事件处理示例

## 概述
EventLoop 现在支持写事件处理。当需要向客户端发送数据时，可以使用写缓冲区和 EPOLLOUT 事件。

## 核心机制

### 1. Client 类新增功能
- **写缓冲区**：`outputBuffer_` 存储待发送的数据
- **事件管理**：通过 `enableWriting()`/`disableWriting()` 控制是否监听写事件
- **回调函数**：支持设置读回调、写完成回调和错误回调

### 2. 工作流程
1. 向 `Client` 的写缓冲区添加数据
2. 启用写事件监听（`enableWriting()`）
3. 调用 `EventLoop::updateClient()` 更新 epoll 监听
4. 当 socket 可写时，触发 EPOLLOUT 事件
5. EventLoop 自动发送数据并管理写事件状态

## 使用示例

### 示例 1：向客户端发送响应
```cpp
void handleClientRequest(std::shared_ptr<Client> client, EventLoop* loop) {
    // 构造响应数据
    std::string response = "HTTP/1.1 200 OK\r\n"
                          "Content-Length: 13\r\n"
                          "\r\n"
                          "Hello, World!";
    
    // 添加到写缓冲区
    client->appendToOutputBuffer(response);
    
    // 启用写事件监听
    client->enableWriting();
    
    // 通知 EventLoop 更新事件监听
    loop->updateClient(client);
}
```

### 示例 2：设置回调函数
```cpp
void setupClientCallbacks(std::shared_ptr<Client> client, EventLoop* loop) {
    // 设置读回调
    client->setReadCallback([loop](Client* c, const char* data, ssize_t len) {
        LOG_DEBUG("Received %ld bytes", len);
        // 处理请求并构造响应
        std::string response = processRequest(data, len);
        
        // 发送响应
        c->appendToOutputBuffer(response);
        c->enableWriting();
        loop->updateClient(std::shared_ptr<Client>(c, [](Client*){})); // 注意：实际使用需要正确管理shared_ptr
    });
    
    // 设置写完成回调
    client->setWriteCompleteCallback([](Client* c) {
        LOG_DEBUG("Write completed for fd=%d", c->getFd());
        // 可以在这里决定是否关闭连接或继续处理
    });
    
    // 设置错误回调
    client->setErrorCallback([](Client* c) {
        LOG_ERROR("Error occurred on fd=%d", c->getFd());
        // 清理资源
    });
}
```

### 示例 3：在游戏服务器中使用
```cpp
class GameServer {
public:
    void handleGameMessage(std::shared_ptr<Client> client, const char* data, ssize_t len) {
        // 解析游戏消息
        GameMessage msg = parseGameMessage(data, len);
        
        // 处理游戏逻辑
        GameResponse response = processGameLogic(msg);
        
        // 序列化响应
        std::string responseData = serializeResponse(response);
        
        // 发送响应
        sendToClient(client, responseData);
    }
    
    void sendToClient(std::shared_ptr<Client> client, const std::string& data) {
        // 添加到写缓冲区
        client->appendToOutputBuffer(data);
        
        // 如果还没有监听写事件，启用它
        if (!client->isWriting()) {
            client->enableWriting();
            loop_->updateClient(client);
        }
        // 如果已经在监听写事件，数据会在下次 EPOLLOUT 时发送
    }
    
private:
    EventLoop* loop_;
};
```

## 注意事项

### 1. 线程安全
`EventLoop::updateClient()` 是线程安全的，会自动检查是否在 EventLoop 线程中执行。

### 2. 自动管理
- 当写缓冲区为空时，EventLoop 会自动禁用 EPOLLOUT 监听，避免频繁触发
- 写完成后会自动调用 `writeCompleteCallback_`

### 3. 错误处理
- 写错误会触发 `errorCallback_` 并自动移除连接
- 需要正确处理 EAGAIN/EWOULDBLOCK（非阻塞场景）

### 4. 性能优化
- 如果数据量小，可以先尝试直接写入，失败后再放入缓冲区
- 大数据传输建议分块发送，避免缓冲区过大

## 与旧代码的兼容性

如果不设置回调函数，读事件仍会像以前一样调用 `handleGameMessage()`。新旧方式可以混用：
- **新方式**：使用回调函数，更灵活
- **旧方式**：继续使用 `handleGameMessage()`，简单直接

## API 参考

### Client 类
```cpp
// 写缓冲区操作
void appendToOutputBuffer(const std::string& data);
void appendToOutputBuffer(const char* data, size_t len);
bool hasDataToWrite() const;

// 事件控制
void enableWriting();
void disableWriting();
bool isWriting() const;

// 回调设置
void setReadCallback(const ReadCallback& cb);
void setWriteCompleteCallback(const WriteCompleteCallback& cb);
void setErrorCallback(const ErrorCallback& cb);
```

### EventLoop 类
```cpp
void updateClient(std::shared_ptr<Client> client); // 更新客户端监听的事件
```
