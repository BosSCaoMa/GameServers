# 会话过期写事件处理示例

## 场景说明

`UserSessionManager::auditSessions()` 是一个定期检查会话是否过期的后台任务，每 5 分钟执行一次。当发现会话过期时，需要：

1. **向客户端发送过期通知**（使用写事件）
2. **等待通知发送完成**
3. **关闭客户端连接**

这是一个完美的**写事件处理**应用场景！

## 完整实现解析

### 1. auditSessions() 核心逻辑

```cpp
void UserSessionManager::auditSessions()
{
    std::scoped_lock lk(mu_);
    auto now = UserSessionCB::Clock::now();
    
    for (auto it = sessions_.begin(); it != sessions_.end(); ) {
        if (it->second->isExpired(now)) {
            LOG_INFO("Auditing: removing expired session token=%s", it->first.c_str());
            
            if (g_eventLoop) {
                int clientFd = it->second->getClientFd();
                
                // 步骤1: 获取 Client 对象
                auto client = g_eventLoop->getClient(clientFd);
                if (client) {
                    // 步骤2: 构造会话过期通知
                    std::string expireNotice = buildSessionExpiredResponse(it->first);
                    
                    // 步骤3: 将通知添加到写缓冲区
                    client->appendToOutputBuffer(expireNotice);
                    
                    // 步骤4: 启用写事件监听
                    client->enableWriting();
                    
                    // 步骤5: 设置写完成回调
                    client->setWriteCompleteCallback([clientFd, eventLoop = g_eventLoop](Client* c) {
                        LOG_INFO("Session expired notice sent to fd=%d, closing connection", clientFd);
                        // 写完成后关闭连接
                        eventLoop->removeClient(clientFd);
                    });
                    
                    // 步骤6: 更新 EventLoop，开始监听 EPOLLOUT
                    g_eventLoop->updateClient(client);
                    
                    LOG_DEBUG("Scheduled session expiry notice for fd=%d", clientFd);
                } else {
                    LOG_DEBUG("Client fd=%d already disconnected", clientFd);
                }
            }
            
            // 从会话列表中移除
            it = sessions_.erase(it);
        } else {
            ++it;
        }
    }
}
```

### 2. 关键步骤详解

#### 步骤1: 获取 Client 对象
```cpp
auto client = g_eventLoop->getClient(clientFd);
```
- 通过文件描述符获取对应的 `Client` 对象
- 如果客户端已断开，返回 `nullptr`

#### 步骤2: 构造响应消息
```cpp
std::string expireNotice = buildSessionExpiredResponse(it->first);
```
构造的 HTTP 响应示例：
```http
HTTP/1.1 401 Unauthorized
Content-Type: application/json
Content-Length: 98
Connection: close

{"error":"session_expired","message":"Your session has expired. Please login again.","token":"abc123"}
```

#### 步骤3: 添加到写缓冲区
```cpp
client->appendToOutputBuffer(expireNotice);
```
- 数据暂存在 `Client` 的 `outputBuffer_` 中
- 此时还**没有发送**

#### 步骤4: 启用写事件
```cpp
client->enableWriting();
```
- 设置 `events_` 标志，包含 `EPOLLOUT`
- 告诉系统我们想监听这个 socket 何时可写

#### 步骤5: 设置回调函数
```cpp
client->setWriteCompleteCallback([clientFd, eventLoop = g_eventLoop](Client* c) {
    LOG_INFO("Session expired notice sent to fd=%d, closing connection", clientFd);
    eventLoop->removeClient(clientFd);
});
```
- Lambda 捕获了 `clientFd` 和 `eventLoop`
- 写完成后自动关闭连接
- **这是优雅关闭的关键**：确保数据发送完毕

#### 步骤6: 更新 EventLoop
```cpp
g_eventLoop->updateClient(client);
```
- 调用 `epoll_ctl(EPOLL_CTL_MOD)` 更新监听事件
- EventLoop 开始监听 `EPOLLOUT` 事件

### 3. EventLoop 中的写事件处理

当 socket 可写时，`EventLoop::handleClient()` 会被触发：

```cpp
// 写事件处理
if (revents & EPOLLOUT) {
    if (client->hasDataToWrite()) {
        const std::string& buffer = client->getOutputBuffer();
        ssize_t n = ::write(fd, buffer.data(), buffer.size());
        
        if (n > 0) {
            LOG_DEBUG("EventLoop wrote %ld bytes to fd=%d", n, fd);
            client->clearOutputBuffer(n);
            
            // 如果写完了，禁用写事件监听
            if (!client->hasDataToWrite()) {
                client->disableWriting();
                updateClient(client);
                client->handleWriteComplete(); // 触发回调！
            }
        } else {
            // 错误处理...
        }
    }
}
```

## 执行时序图

```
[后台审计线程]              [EventLoop 线程]            [网络]
      |                           |                        |
      | auditSessions()           |                        |
      |-------------------------->|                        |
      | 发现过期会话              |                        |
      |                           |                        |
      | getClient(fd)             |                        |
      |<--------------------------|                        |
      |                           |                        |
      | appendToOutputBuffer()    |                        |
      | enableWriting()           |                        |
      | setWriteCompleteCallback()|                        |
      | updateClient()            |                        |
      |-------------------------->|                        |
      |                           | epoll_ctl(MOD, EPOLLOUT)
      |                           |----------------------->|
      |                           |                        |
      |                           | [等待 EPOLLOUT 事件]   |
      |                           |                        |
      |                           |<----- EPOLLOUT --------|
      |                           | handleClient()         |
      |                           | write(fd, buffer)      |
      |                           |----------------------->|
      |                           |                        |
      |                           | 写完成！               |
      |                           | disableWriting()       |
      |                           | handleWriteComplete()  |
      |                           |   |                    |
      |                           |   | 触发回调           |
      |                           |   | removeClient(fd)   |
      |                           |   |                    |
      |                           | close(fd)              |
      |                           |----------------------->|
```

## 为什么不能直接 write()?

你可能会问：为什么不直接在 `auditSessions()` 中调用 `write()`？

### 问题1: 阻塞风险
```cpp
// ❌ 错误做法
write(clientFd, expireNotice.data(), expireNotice.size());
```
- 如果 socket 发送缓冲区满了，`write()` 会阻塞或返回 `EAGAIN`
- 审计线程被阻塞，影响其他会话检查

### 问题2: 跨线程操作
```cpp
// ❌ 危险操作
write(clientFd, ...);  // 在审计线程直接写
```
- `clientFd` 由 EventLoop 线程管理
- 可能与 EventLoop 的读操作竞争

### 问题3: 无法保证完整发送
```cpp
// ❌ 无法保证发送完整
ssize_t n = write(clientFd, data, len);
if (n < len) {
    // 怎么办？剩余的数据怎么处理？
}
```

## 正确做法的优势

✅ **非阻塞**：写事件触发时才发送，不会阻塞  
✅ **线程安全**：所有 I/O 操作在 EventLoop 线程  
✅ **可靠性**：自动处理部分写入，直到全部发送  
✅ **优雅关闭**：确保数据发送完才关闭连接  

## 其他应用场景

这个写事件机制还可以用于：

### 1. 服务器推送通知
```cpp
void broadcastMessage(const std::string& message) {
    for (auto& [fd, client] : allClients) {
        client->appendToOutputBuffer(message);
        client->enableWriting();
        g_eventLoop->updateClient(client);
    }
}
```

### 2. 大文件传输
```cpp
void sendFile(std::shared_ptr<Client> client, const std::string& filePath) {
    // 分块读取文件并发送
    client->setWriteCompleteCallback([filePath, offset = 0](Client* c) mutable {
        // 继续读取下一块...
    });
}
```

### 3. 流式响应
```cpp
void streamResponse(std::shared_ptr<Client> client) {
    client->appendToOutputBuffer("HTTP/1.1 200 OK\r\n");
    client->appendToOutputBuffer("Transfer-Encoding: chunked\r\n\r\n");
    client->enableWriting();
    
    client->setWriteCompleteCallback([](Client* c) {
        // 发送下一个 chunk...
    });
}
```

## 总结

`auditSessions()` 展示了写事件处理的完整流程：

1. **准备数据** → `appendToOutputBuffer()`
2. **启用写监听** → `enableWriting()`
3. **设置回调** → `setWriteCompleteCallback()`
4. **通知 EventLoop** → `updateClient()`
5. **自动发送** → EventLoop 检测到 `EPOLLOUT` 时发送
6. **触发回调** → 发送完成后执行清理

这是一个**生产级别的异步写处理模式**！
